# 简单总结你实现的功能（200字以内，不要贴代码）及你完成本次实验所用的时间

完成了死锁检测的系统调用，和死锁检测功能，其中互斥锁判断和信号量判断共用同一套资源和判断方法(题目保证了不会混用)

做了2天多，大概8个多小时左右，大部分时间用于阅读文档和调试bug

# 问答作业

## 在我们的多线程实现中，当主线程 (即 0 号线程) 退出时，视为整个进程退出， 此时需要结束该进程管理的所有线程并回收其资源。 - 需要回收的资源有哪些？ - 其他线程的 TaskControlBlock 可能在哪些位置被引用，分别是否需要回收，为什么？

主线程（即tid为0的线程）退出时，整个进程的资源回收主要包括以下几个方面：

1. **TaskUserRes资源**：这包括每个线程的tid、trap上下文(trap_cx)、用户栈(ustack)等。这些资源在遍历`process_inner.tasks`时通过`task_inner.res.take()`被收集到`recycle_res`向量中，并最终被清理以避免内存泄露。
2. **内核栈和Trap上下文**：虽然代码中没有直接体现内核栈（kstack）的回收，但注释中提到当所有相关处理完成后，内核栈将随着任务结构体的销毁而被释放。Trap上下文通常随TaskUserRes一起被管理，因此也在回收之列。
3. **用户空间内存**：通过`process_inner.memory_set.recycle_data_pages()`回收程序的代码段、数据段等用户空间内存。
4. **文件描述符表**：通过`process_inner.fd_table.clear()`清理打开的文件描述符，释放与文件系统相关的资源。
5. **子进程管理**：将当前进程的子进程转移给init进程（INITPROC），确保它们能够继续运行，同时清空原进程的子进程列表。

其他线程的`TaskControlBlock`的引用位置及其处理：

- **Processor**: 当前线程通过`take_current_task()`从Processor中取出，此时Processor对它的引用自然解除。对于已经退出但未被完全清理的线程（如非主线程），它们可能依然存在于Processor的就绪队列或等待队列中，但此代码片段中通过`remove_inactive_task`函数从TaskManager中移除，间接地处理了这些引用，确保不会产生悬挂引用。
- **TaskManager**: 其他线程如果处于就绪、阻塞等状态，其`TaskControlBlock`会被TaskManager引用。在这个过程中，通过调用`remove_inactive_task`，会检查并移除这些线程，从而解除TaskManager对它们的引用，确保资源能被正确回收。

## 对比以下两种 `Mutex.unlock` 的实现，二者有什么区别？这些区别可能会导致什么问题？ 

主要区别在于解锁后唤醒等待任务的逻辑不同

### Mutex1的实现

如果等待队列中有任务，则将队列头部的任务加入到就绪队列，准备执行。

### Mutex2的实现

仅当等待队列为空时，才将`locked`状态设为`false`。如果队列中有任务，则保持锁定状态直到所有等待的任务都被处理完。

### 可能导致的问题

Mutex2可能会发生死锁问题，不过对于当前的rcore内核而言不会出现死锁状况

Mutex2还需要注意`lock`和用户使用上的实现问题，如果出现重复上锁，那么锁可能永远无法释放了

# 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 **以下各位** 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

   > *《同交流群内 下水道鼠鼠 和 苦瓜小仔 对银行家算法实现进行了交流》*

2. 此外，我也参考了 **以下资料** ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

   > *《rCore-Tutorial-Book 第三版》*

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
